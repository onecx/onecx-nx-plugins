import { HttpClientTestingModule } from '@angular/common/http/testing';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { FormBuilder, ReactiveFormsModule } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { TestbedHarnessEnvironment } from '@angular/cdk/testing/testbed';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { By } from '@angular/platform-browser';
import { LetDirective } from '@ngrx/component';
import { Store, StoreModule } from '@ngrx/store';
import { MockStore, provideMockStore } from '@ngrx/store/testing';
import { ofType } from '@ngrx/effects';
import { TranslateService } from '@ngx-translate/core';
import { TranslateTestingModule } from 'ngx-translate-testing';
import { DialogService } from 'primeng/dynamicdialog';
import { 
  BreadcrumbService,
  HAS_PERMISSION_CHECKER,
  ColumnType,
  PortalCoreModule,
  UserService,
  providePortalDialogService
} from '@onecx/portal-integration-angular';
import { <%= featureClassName %>SearchActions } from './<%= featureFileName %>-search.actions';
import { <%= featureClassName %>SearchComponent } from './<%= featureFileName %>-search.component';
import { <%= featureClassName %>SearchHarness } from './<%= featureFileName %>-search.harness';
import { <%= featureClassName %>SearchViewModel } from './<%= featureFileName %>-search.viewmodel';
import { <%= featurePropertyName %>SearchColumns } from './<%= featureFileName %>-search.columns';
import { select<%= featureClassName %>SearchViewModel } from './<%= featureFileName %>-search.selectors';
import { initialState } from './<%= featureFileName %>-search.reducers';
import { provideUserServiceMock } from '@onecx/angular-integration-interface/mocks';

describe('<%= featureClassName %>SearchComponent', () => {
  const origAddEventListener = window.addEventListener;
  const origPostMessage = window.postMessage;

  let listeners: any[] = [];
  window.addEventListener = (_type: any, listener: any) => {
    listeners.push(listener);
  };

  window.removeEventListener = (_type: any, listener: any) => {
    listeners = listeners.filter((l) => l !== listener);
  };

  window.postMessage = (m: any) => {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    listeners.forEach((l) =>
      l({
        data: m,
        stopImmediatePropagation: () => {},
        stopPropagation: () => {},
      })
    );
  };

  afterAll(() => {
    window.addEventListener = origAddEventListener;
    window.postMessage = origPostMessage;
  });


  HTMLCanvasElement.prototype.getContext = jest.fn();
  let component: <%= featureClassName %>SearchComponent;
  let fixture: ComponentFixture<<%= featureClassName %>SearchComponent>;
  let store: MockStore<Store>;
  let formBuilder: FormBuilder;
  let <%= featurePropertyName %>Search: <%= featureClassName %>SearchHarness;
  
  const mockActivatedRoute = {
    snapshot: {
      data: {},
    },
  };
  const base<%= featureClassName %>SearchViewModel: <%= featureClassName %>SearchViewModel = {
    columns: <%= featurePropertyName %>SearchColumns,
    searchCriteria: { changeMe: '0' },
    searchExecuted: true,
    results: [],
    searchLoadingIndicator: false,
    diagramComponentState: null,
    resultComponentState: null,
    searchHeaderComponentState: null,
    chartVisible: false,
  };

  beforeAll(() => {
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: jest.fn().mockImplementation((query) => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: jest.fn(), // Deprecated
        removeListener: jest.fn(), // Deprecated
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn(),
      })),
    });
  });

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [<%= featureClassName %>SearchComponent],
      imports: [
        PortalCoreModule,
        LetDirective,
        ReactiveFormsModule,
        StoreModule.forRoot({}),
        TranslateTestingModule.withTranslations(
          'en',
          require('./../../../../assets/i18n/en.json')
        ).withTranslations('de', require('./../../../../assets/i18n/de.json')),
        HttpClientTestingModule,
        NoopAnimationsModule,
      ],
      providers: [
        DialogService,
        provideMockStore({
          initialState: { <%= featurePropertyName %>: { search: initialState } },
        }),
        FormBuilder,
        providePortalDialogService(),
        { provide: ActivatedRoute, useValue: mockActivatedRoute },
        provideUserServiceMock(),
        {
            provide: HAS_PERMISSION_CHECKER,
            useExisting: UserService,
        },
      ],
    }).compileComponents();
  });

  beforeEach(async () => {
    const userService = TestBed.inject(UserService);
    userService.permissions$.next([
      "<%= featureConstantName %>#CREATE",
      "<%= featureConstantName %>#EDIT",
      "<%= featureConstantName %>#DELETE",
      "<%= featureConstantName %>#IMPORT",
      "<%= featureConstantName %>#EXPORT",
      "<%= featureConstantName %>#VIEW",
      "<%= featureConstantName %>#SEARCH",
      "<%= featureConstantName %>#BACK"
    ])
    userService.hasPermission = () => true;
    const translateService = TestBed.inject(TranslateService);
    translateService.use('en');
    formBuilder = TestBed.inject(FormBuilder);

    store = TestBed.inject(MockStore);
    jest.spyOn(store, 'dispatch')
    store.overrideSelector(
      select<%= featureClassName %>SearchViewModel,
      base<%= featureClassName %>SearchViewModel
    );
    store.refreshState();

    fixture = TestBed.createComponent(<%= featureClassName %>SearchComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    <%= featurePropertyName %>Search = await TestbedHarnessEnvironment.harnessForFixture(
      fixture,
      <%= featureClassName %>SearchHarness
    );
  });

  it('should create the component', () => {
    expect(component).toBeTruthy();
  });

  it('should dispatch resetButtonClicked action on resetSearch', async () => {    
    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: [
        {
          id: '1',
          imagePath: '',
          changeMe: 'val_1',
        },
      ],
      columns: [
        {
          columnType: ColumnType.STRING,
          id: 'changeMe',
          nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
          filterable: true,
          sortable: true,
          predefinedGroupKeys: [
            'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
            'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
            'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
          ],
        },
      ],
    });
    store.refreshState();

    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    await searchHeader.clickResetButton();

    expect(store.dispatch).toHaveBeenCalledWith(
      <%= featurePropertyName %>SearchActions.resetButtonClicked()
    );
  });

  it('should have 2 overFlow header actions when search config is disabled', async () => {
    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    const pageHeader = await searchHeader.getPageHeader();
    const overflowActionButton = await pageHeader.getOverflowActionMenuButton();
    await overflowActionButton?.click();

    const overflowMenuItems = await pageHeader.getOverFlowMenuItems();
    expect(overflowMenuItems.length).toBe(2);

    const exportAllActionItem = await pageHeader.getOverFlowMenuItem(
      'Export all'
    );
    expect(await exportAllActionItem!.getText()).toBe('Export all');

    const showHideChartActionItem = await pageHeader.getOverFlowMenuItem(
      'Show chart'
    );
    expect(await showHideChartActionItem!.getText()).toBe('Show chart');
  });

  it('should display hide chart action if chart is visible', async () => {
    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      chartVisible: true,
    });
    store.refreshState();

    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    const pageHeader = await searchHeader.getPageHeader();
    const overflowActionButton = await pageHeader.getOverflowActionMenuButton();
    await overflowActionButton?.click();

    const overflowMenuItems = await pageHeader.getOverFlowMenuItems();
    expect(overflowMenuItems.length).toBe(2);

    const showHideChartActionItem = await pageHeader.getOverFlowMenuItem(
      'Hide chart'
    );
    expect(await showHideChartActionItem!.getText()).toEqual('Hide chart');
  });

  it('should display chosen column in the diagram', async () => {
    component.diagramColumnId = 'changeMe';
    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      chartVisible: true,
      results: [
        {
          id: '1',
          imagePath: '',
          changeMe: 'val_1',
        },
        {
          id: '2',
          imagePath: '',
          changeMe: 'val_2',
        },
        {
          id: '3',
          imagePath: '',
          changeMe: 'val_2',
        },
      ],
      columns: [
        {
          columnType: ColumnType.STRING,
          id: 'changeMe',
          nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
          filterable: true,
          sortable: true,
          predefinedGroupKeys: [
            'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
            'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
            'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
          ],
        },
      ],
    });
    store.refreshState();

    const diagram =
      await (await <%= featurePropertyName %>Search.getDiagram())!.getDiagram();

    expect(await diagram.getTotalNumberOfResults()).toBe(3);
    expect(await diagram.getSumLabel()).toEqual('Total');
  });

  it('should display correct breadcrumbs', async () => {
    const breadcrumbService = TestBed.inject(BreadcrumbService);
    jest.spyOn(breadcrumbService, 'setItems');

    component.ngOnInit();
    fixture.detectChanges();

    expect(breadcrumbService.setItems).toHaveBeenCalledTimes(1);
    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    const pageHeader = await searchHeader.getPageHeader();
    const searchBreadcrumbItem = await pageHeader.getBreadcrumbItem('Search');

    expect(await searchBreadcrumbItem!.getText()).toEqual('Search');
  });

  it('should dispatch displayedColumnsChanged on data view column change', async () => {
    jest.spyOn(store, 'dispatch');
    const columns = [
      {
        columnType: ColumnType.STRING,
        id: 'changeMe',
        nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
        filterable: true,
        sortable: true,
        predefinedGroupKeys: [
          'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
          'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
          'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
        ],
      },
    ];
    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: [],
      columns: columns,
      displayedColumns: columns,
    });
    store.refreshState();
  
    const interactiveDataView =
      await <%= featurePropertyName %>Search.getSearchResults();        
    (await (
        await interactiveDataView.getDataLayoutSelection()
      ).getTableLayoutSelectionButton()
    )?.click();

    const columnGroupSelector =
      await interactiveDataView?.getCustomGroupColumnSelector();
    expect(columnGroupSelector).toBeTruthy();

    await columnGroupSelector!.openCustomGroupColumnSelectorDialog();
    const pickList = await columnGroupSelector!.getPicklist();
    const transferControlButtons = await pickList.getTransferControlsButtons();
    expect(transferControlButtons.length).toBe(4);

    // Currently, all columns are selected. Next, we are unselecting all to have a clean test setting.
    const deactivateAllColumnsButton = transferControlButtons[1];
    await deactivateAllColumnsButton.click();
    const inactiveItems = await pickList.getTargetListItems();
    await inactiveItems[0].selectItem();
    const activateCurrentColumnButton = transferControlButtons[2];
    await activateCurrentColumnButton.click();
    const saveButton = await columnGroupSelector!.getSaveButton();
    await saveButton.click();

    expect(store.dispatch).toHaveBeenLastCalledWith(
       expect.objectContaining({ displayedColumns: columns })
    );
  });

  it('should dispatch chartVisibilityToggled on show/hide chart header', async () => {
    jest.spyOn(store, 'dispatch');

    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      chartVisible: false,
    });
    store.refreshState();

    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    const pageHeader = await searchHeader.getPageHeader();
    const overflowActionButton = await pageHeader.getOverflowActionMenuButton();
    await overflowActionButton?.click();

    const showChartActionItem = await pageHeader.getOverFlowMenuItem(
      'Show chart'
    );
    await showChartActionItem!.selectItem();
    expect(store.dispatch).toHaveBeenCalledWith(
      <%= featureClassName %>SearchActions.chartVisibilityToggled()
    );
  });  

  it('should display translated headers', async () => {
    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    const pageHeader = await searchHeader.getPageHeader();
    expect(await pageHeader.getHeaderText()).toEqual('<%= featureClassName %> Search');
    expect(await pageHeader.getSubheaderText()).toEqual(
      'Searching and displaying of <%= featureClassName %>'
    );
  });

  it('should display translated empty message when no search results', async () => {
    const columns = [
      {
        columnType: ColumnType.STRING,
        id: 'changeMe',
        nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
        filterable: true,
        sortable: true,
        predefinedGroupKeys: [
          'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
          'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
          'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
        ],
      },
    ];
    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: [],
      columns: columns,
      displayedColumns: columns,
    });
    store.refreshState();

    const interactiveDataView =
      await <%= featurePropertyName %>Search.getSearchResults();
    const dataView = await interactiveDataView.getDataView();
    const dataTable = await dataView.getDataListGrid();
    const rows = await dataTable!.getActionButtons('list');
    expect(rows.length).toBe(0);
    expect(
      fixture.debugElement.query(By.css('.p-dataview-emptymessage')),
    ).toBeDefined();
  });

  it('should not display chart when no results or toggled to not visible', async () => {
    component.diagramColumnId = 'changeMe';

    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: [],
      chartVisible: true,
      columns: [
        {
        columnType: ColumnType.STRING,
        id: 'changeMe',
        nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
        filterable: true,
        sortable: true,
        predefinedGroupKeys: [
          'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
          'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
          'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
        ],
      },
      ],
    });
    store.refreshState();

    let diagram = await <%= featurePropertyName %>Search.getDiagram();
    expect(diagram).toBeNull();

    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: [
        {
          id: '1',
          imagePath: '',
          changeMe: 'val_1',
        },
      ],
      chartVisible: false,
      columns: [
        {
          columnType: ColumnType.STRING,
          id: 'changeMe',
          nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
          filterable: true,
          sortable: true,
          predefinedGroupKeys: [
            'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
            'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
            'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
          ],
        },
      ],
    });
    store.refreshState();

    diagram = await <%= featurePropertyName %>Search.getDiagram();
    expect(diagram).toBeNull();

    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: [
        {
          id: '1',
          imagePath: '',
          changeMe: 'val_1',
        },
      ],
      chartVisible: true,
      columns: [
        {
        columnType: ColumnType.STRING,
        id: 'changeMe',
        nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
        filterable: true,
        sortable: true,
        predefinedGroupKeys: [
          'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
          'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
          'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
        ],
      },
      ],
    });
    store.refreshState();

    diagram = await <%= featurePropertyName %>Search.getDiagram();
    expect(diagram).toBeTruthy();
  });

  it('should export csv data on export action click', async () => {
    jest.spyOn(store, 'dispatch');
  
    const results = [
      {
        id: '1',
        imagePath: '',
        changeMe: 'val_1',
      },
    ];
    const columns = [
      {
        columnType: ColumnType.STRING,
        id: 'changeMe',
        nameKey: 'HELLO_SEARCH.RESULTS.HELLO',
        filterable: true,
        sortable: true,
        predefinedGroupKeys: [
          'HELLO_SEARCH.PREDEFINED_GROUP.DEFAULT',
          'HELLO_SEARCH.PREDEFINED_GROUP.EXTENDED',
          'HELLO_SEARCH.PREDEFINED_GROUP.FULL'
        ],
      },
    ];
    store.overrideSelector(select<%= featureClassName %>SearchViewModel, {
      ...base<%= featureClassName %>SearchViewModel,
      results: results,
      columns: columns,
      displayedColumns: columns,
    });
    store.refreshState();
  
    const searchHeader = await <%= featurePropertyName %>Search.getHeader();
    const pageHeader = await searchHeader.getPageHeader();
    const overflowActionButton = await pageHeader.getOverflowActionMenuButton();
    await overflowActionButton?.click();
  
    const exportAllActionItem = await pageHeader.getOverFlowMenuItem(
      'Export all'
    );
    await exportAllActionItem!.selectItem();

    expect(store.dispatch).toHaveBeenCalledWith(
      <%= featureClassName %>SearchActions.exportButtonClicked()
    );
  });

  describe('searchCriteria mapping', () => {

    it('should convert Date values to UTC and dispatch searchButtonClicked', () => {
      const formValue = { changeMe: new Date(2024, 4, 15, 12, 30, 45) };
      const expected = { changeMe: new Date(Date.UTC(2024, 4, 15, 12, 30, 45)) };

      component.<%= featurePropertyName %>SearchFormGroup = {
        value: formValue,
        getRawValue: () => formValue,
      } as any;

      component.search(component.<%= featurePropertyName %>SearchFormGroup);

      const calls = (store.dispatch as jest.Mock).mock.calls;
      expect(calls.length).toBeGreaterThan(0);
      const lastAction = calls[calls.length - 1][0];
      expect(lastAction.type).toBe(<%= featureClassName %>SearchActions.searchButtonClicked.type);
      expect(lastAction.searchCriteria).toEqual(expected);
    });

    it('should pass through non-date, non-empty values unchanged', () => {
      const formValue = { changeMe: 'testName' };
      const expected = { changeMe: 'testName' };

      component.<%= featurePropertyName %>SearchFormGroup = {
        value: formValue,
        getRawValue: () => formValue,
      } as any;

      component.search(component.<%= featurePropertyName %>SearchFormGroup);

      const calls = (store.dispatch as jest.Mock).mock.calls;
      expect(calls.length).toBeGreaterThan(0);
      const lastAction = calls[calls.length - 1][0];
      expect(lastAction.type).toBe(<%= featureClassName %>SearchActions.searchButtonClicked.type);
      expect(lastAction.searchCriteria).toEqual(expected);
    });

    it('should set searchCriteria property to undefined for falsy non-date values', () => {
      const formValue = { changeMe: '' };
      const expected = { changeMe: undefined };

      component.<%= featurePropertyName %>SearchFormGroup = {
        value: formValue,
        getRawValue: () => formValue,
      } as any;

      component.search(component.<%= featurePropertyName %>SearchFormGroup);

      const calls = (store.dispatch as jest.Mock).mock.calls;
      expect(calls.length).toBeGreaterThan(0);
      const lastAction = calls[calls.length - 1][0];
      expect(lastAction.type).toBe(<%= featureClassName %>SearchActions.searchButtonClicked.type);
      expect(lastAction.searchCriteria).toEqual(expected);
    });
  });

  describe('actions dispatch', () => {
    it('should dispatch resultComponentStateChanged when resultComponentStateChanged is called', () => {
      const payload = { activeColumnGroupKey: 'test-group' };
      component.resultComponentStateChanged(payload);
      expect(store.dispatch).toHaveBeenCalledWith(<%= featureClassName %>SearchActions.resultComponentStateChanged(payload));
    });

    it('should dispatch searchHeaderComponentStateChanged when searchHeaderComponentStateChanged is called', () => {
      const payload = {
        activeViewMode: 'basic',
        selectedSearchConfig: 'config1',
      } as SearchHeaderComponentState;
      component.searchHeaderComponentStateChanged(payload);
      expect(store.dispatch).toHaveBeenCalledWith(<%= featureClassName %>SearchActions.searchHeaderComponentStateChanged(payload));
    });

    it('should dispatch diagramComponentStateChanged when diagramComponentStateChanged is called', () => {
      const payload = { label: 'Test Diagram' } as GroupByCountDiagramComponentState;
      component.diagramComponentStateChanged(payload);
      expect(store.dispatch).toHaveBeenCalledWith(<%= featureClassName %>SearchActions.diagramComponentStateChanged(payload));
    });
  });

// <<SPEC-EXTENSIONS-MARKER-!!!-DO-NOT-REMOVE-!!!>>
});